#!/usr/bin/env python3
import time

print("Content-type: text/html")
print()

print('''
<html>
<head>
    <title>Long Running Process with Countdown</title>
    <script type="text/javascript">
        var count = 30;
        function countdown() {
            if (count == 0) {
                document.getElementById("countdown").innerHTML = "Process is still running on the server... Please wait.";
            } else {
                document.getElementById("countdown").innerHTML = count + " seconds remaining";
                count--;
                setTimeout("countdown()", 1000);
            }
        }
    </script>
</head>
<body onload="countdown()">
    <h2>Countdown from 30 to 0</h2>
    <div id="countdown"></div>
	<p>The entire HTTP response, including headers and body, is generated by your CGI script before it's sent to the client (browser). However, the response isn't actually transmitted until the script completes execution.</p>
	<p>This script uses JavaScript to handle the countdown logic. The countdown begins automatically when the page loads, thanks to the body tag's onload attribute, which calls the countdown() function. The countdown is displayed in a <div> element with the id countdown, and it updates every second until it reaches 0, at which point it displays "Blast off!".</p>
	<p>but this is just the illusion of a long running script, what makes it long lasting is the time.sleep(35) python function that makes the script sleep for 35 seconds. After the pause, it will complete the HTML response, indicating that the long-running process has finished..
 </p>

''')

# Simulate a long-running process on the server
time.sleep(8)

print('''
    <p>The long-running process has finished. Blast off!</p>
</body>
</html>
''')
